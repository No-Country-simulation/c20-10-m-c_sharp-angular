"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RULE_NAME = exports.OrderType = void 0;
const bundled_angular_compiler_1 = require("@angular-eslint/bundled-angular-compiler");
const utils_1 = require("@angular-eslint/utils");
const create_eslint_rule_1 = require("../utils/create-eslint-rule");
var OrderType;
(function (OrderType) {
    OrderType["TemplateReferenceVariable"] = "TEMPLATE_REFERENCE";
    OrderType["StructuralDirective"] = "STRUCTURAL_DIRECTIVE";
    OrderType["AttributeBinding"] = "ATTRIBUTE_BINDING";
    OrderType["InputBinding"] = "INPUT_BINDING";
    OrderType["OutputBinding"] = "OUTPUT_BINDING";
    OrderType["TwoWayBinding"] = "TWO_WAY_BINDING";
})(OrderType || (exports.OrderType = OrderType = {}));
exports.RULE_NAME = 'attributes-order';
const DEFAULT_ORDER = [
    OrderType.StructuralDirective,
    OrderType.TemplateReferenceVariable,
    OrderType.AttributeBinding,
    OrderType.InputBinding,
    OrderType.TwoWayBinding,
    OrderType.OutputBinding,
];
const DEFAULT_OPTIONS = {
    alphabetical: false,
    order: [...DEFAULT_ORDER],
};
exports.default = (0, create_eslint_rule_1.createESLintRule)({
    name: exports.RULE_NAME,
    meta: {
        type: 'layout',
        docs: {
            description: 'Ensures that HTML attributes and Angular bindings are sorted based on an expected order',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    alphabetical: {
                        type: 'boolean',
                        default: DEFAULT_OPTIONS.alphabetical,
                    },
                    order: {
                        type: 'array',
                        items: {
                            type: 'string',
                            enum: DEFAULT_OPTIONS.order,
                        },
                        default: DEFAULT_OPTIONS.order,
                        minItems: DEFAULT_OPTIONS.order.length,
                        uniqueItems: true,
                    },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            attributesOrder: `The element's attributes/bindings did not match the expected order: expected {{expected}} instead of {{actual}}`,
        },
    },
    defaultOptions: [DEFAULT_OPTIONS],
    create(context, [{ alphabetical, order }]) {
        const parserServices = (0, utils_1.getTemplateParserServices)(context);
        function getLocation(attr) {
            const loc = parserServices.convertNodeSourceSpanToLoc(attr.sourceSpan);
            switch (attr.orderType) {
                case OrderType.StructuralDirective:
                    return {
                        start: {
                            line: loc.start.line,
                            column: loc.start.column - 1,
                        },
                        end: {
                            line: loc.end.line,
                            column: loc.end.column + (isValuelessStructuralDirective(attr) ? 0 : 1),
                        },
                    };
                default:
                    return loc;
            }
        }
        return {
            ['Element$1, Template'](node) {
                if (isImplicitTemplate(node)) {
                    return;
                }
                const { attributes, inputs, outputs, references } = node;
                const { extractedBananaBoxes, extractedInputs, extractedOutputs } = normalizeInputsOutputs(inputs.map(toInputBindingOrderType), outputs.map(toOutputBindingOrderType));
                const allAttributes = [
                    ...extractTemplateAttrs(node),
                    ...attributes.map(toAttributeBindingOrderType),
                    ...references.map(toTemplateReferenceVariableOrderType),
                    ...extractedBananaBoxes,
                    ...extractedInputs,
                    ...extractedOutputs,
                ];
                if (allAttributes.length < 2) {
                    return;
                }
                const sortedAttributes = [...allAttributes].sort(byLocation);
                const expectedAttributes = [...allAttributes].sort(byOrder(order, alphabetical));
                let errorRange;
                for (let i = 0; i < sortedAttributes.length; i++) {
                    if (sortedAttributes[i] !== expectedAttributes[i]) {
                        errorRange = [errorRange?.[0] ?? i, i];
                    }
                }
                if (errorRange) {
                    const [startIndex, endIndex] = errorRange;
                    const sourceCode = context.sourceCode;
                    const { start } = getLocation(sortedAttributes[startIndex]);
                    const { end } = getLocation(sortedAttributes[endIndex]);
                    const loc = { start, end };
                    const range = [
                        getStartPos(sortedAttributes[startIndex]),
                        getEndPos(sortedAttributes[endIndex]),
                    ];
                    let replacementText = '';
                    let lastPos = range[0];
                    for (let i = startIndex; i <= endIndex; i++) {
                        const oldAttr = sortedAttributes[i];
                        const oldStart = getStartPos(oldAttr);
                        const oldEnd = getEndPos(oldAttr);
                        const newAttr = expectedAttributes[i];
                        const newStart = getStartPos(newAttr);
                        const newEnd = getEndPos(newAttr);
                        replacementText += sourceCode.text.slice(lastPos, oldStart);
                        replacementText += sourceCode.text.slice(newStart, newEnd);
                        lastPos = oldEnd;
                    }
                    context.report({
                        loc,
                        messageId: 'attributesOrder',
                        data: {
                            expected: expectedAttributes
                                .slice(startIndex, endIndex + 1)
                                .map((a) => `\`${getMessageName(a)}\``)
                                .join(', '),
                            actual: sortedAttributes
                                .slice(startIndex, endIndex + 1)
                                .map((a) => `\`${getMessageName(a)}\``)
                                .join(', '),
                        },
                        fix: (fixer) => fixer.replaceTextRange(range, replacementText),
                    });
                }
            },
        };
    },
});
function byLocation(one, other) {
    return one.sourceSpan.start.line === other.sourceSpan.start.line
        ? one.sourceSpan.start.col - other.sourceSpan.start.col
        : one.sourceSpan.start.line - other.sourceSpan.start.line;
}
function byOrder(order, alphabetical) {
    return function (one, other) {
        const orderComparison = getOrderIndex(one, order) - getOrderIndex(other, order);
        if (alphabetical && orderComparison === 0) {
            const oneName = one.keySpan?.details ?? one.name;
            const oneNormalised = oneName.replace(/^i18n-/, '');
            const otherName = other.keySpan?.details ?? other.name;
            const otherNormalised = otherName.replace(/^i18n-/, '');
            if (oneNormalised === otherNormalised) {
                return /^i18n-/.test(oneName) ? 1 : -1;
            }
            return oneNormalised > otherNormalised ? 1 : -1;
        }
        return orderComparison;
    };
}
function getOrderIndex(attr, order) {
    return order.indexOf(attr.orderType);
}
function toAttributeBindingOrderType(attribute) {
    return {
        ...attribute,
        orderType: OrderType.AttributeBinding,
    };
}
function toInputBindingOrderType(input) {
    return {
        ...input,
        orderType: OrderType.InputBinding,
    };
}
function toStructuralDirectiveOrderType(attributeOrInput) {
    return {
        ...attributeOrInput,
        orderType: OrderType.StructuralDirective,
    };
}
function toOutputBindingOrderType(output) {
    return {
        ...output,
        orderType: OrderType.OutputBinding,
    };
}
function toTwoWayBindingOrderType(output) {
    return {
        ...output,
        orderType: OrderType.TwoWayBinding,
    };
}
function toTemplateReferenceVariableOrderType(reference) {
    return {
        ...reference,
        orderType: OrderType.TemplateReferenceVariable,
    };
}
function isImplicitTemplate(node) {
    return isTmplAstTemplate(node) && node.tagName !== 'ng-template';
}
function extractTemplateAttrs(node) {
    if (isTmplAstTemplate(node)) {
        return node.templateAttrs.map(toStructuralDirectiveOrderType).concat(node.variables.map((x) => {
            return {
                ...toAttributeBindingOrderType(x),
                // `let-` is excluded from the keySpan and name - add it back in
                keySpan: new bundled_angular_compiler_1.ParseSourceSpan(x.keySpan.start.moveBy(-4), x.keySpan.end),
                name: 'let-' + x.name,
            };
        }));
    }
    if (!isImplicitTemplate(node.parent)) {
        return [];
    }
    /*
     * There may be multiple "attributes" for a structural directive even though
     * there is only a single HTML attribute:
     * e.g. `<ng-container *ngFor="let foo of bar"></ng-container>`
     * will parsed as two attributes (`ngFor` and `ngForOf`)
     */
    const attrs = node.parent.templateAttrs.map(toStructuralDirectiveOrderType);
    let keyEnd = attrs[0].keySpan?.end;
    if (keyEnd?.getContext(0, 0)?.after === '=') {
        keyEnd = keyEnd.moveBy(1);
        const apos = keyEnd.getContext(0, 0)?.after;
        if (apos === "'" || apos === '"') {
            do {
                keyEnd = keyEnd.moveBy(1);
            } while (keyEnd.getContext(0, 0)?.after !== apos);
        }
        else {
            while (!/[\s>]/.test(keyEnd.getContext(0, 0)?.after ?? '')) {
                keyEnd = keyEnd.moveBy(1);
            }
        }
        return [
            {
                ...attrs[0],
                sourceSpan: new bundled_angular_compiler_1.ParseSourceSpan(attrs[0].sourceSpan.start, keyEnd),
            },
        ];
    }
    return [attrs[0]];
}
function normalizeInputsOutputs(inputs, outputs) {
    const extractedInputs = inputs
        .filter((input) => !outputs.some((output) => isOnSameLocation(input, output)))
        .map(toInputBindingOrderType);
    const { extractedBananaBoxes, extractedOutputs } = outputs.reduce(({ extractedBananaBoxes, extractedOutputs }, output) => {
        const boundInput = inputs.find((input) => isOnSameLocation(input, output));
        return {
            extractedBananaBoxes: extractedBananaBoxes.concat(boundInput ? toTwoWayBindingOrderType(boundInput) : []),
            extractedOutputs: extractedOutputs.concat(boundInput ? [] : toOutputBindingOrderType(output)),
        };
    }, { extractedBananaBoxes: [], extractedOutputs: [] });
    return { extractedBananaBoxes, extractedInputs, extractedOutputs };
}
function isTmplAstTemplate(node) {
    return node instanceof bundled_angular_compiler_1.TmplAstTemplate;
}
function isOnSameLocation(input, output) {
    return (input.sourceSpan.start === output.sourceSpan.start &&
        input.sourceSpan.end === output.sourceSpan.end);
}
function getMessageName(expected) {
    const fullName = expected.keySpan?.details ?? expected.name;
    switch (expected.orderType) {
        case OrderType.StructuralDirective:
            return `*${fullName}`;
        case OrderType.TemplateReferenceVariable:
            return `#${fullName}`;
        case OrderType.InputBinding:
            return `[${fullName}]`;
        case OrderType.OutputBinding:
            return `(${fullName})`;
        case OrderType.TwoWayBinding:
            return `[(${fullName})]`;
        default:
            return fullName;
    }
}
function isValuelessStructuralDirective(attr) {
    if (attr.orderType !== OrderType.StructuralDirective || !attr.keySpan) {
        return false;
    }
    const attrSpan = attr.sourceSpan;
    const keySpan = attr.keySpan;
    /**
     * A valueless structural directive will have the same span as its key.
     * TextAttribute[value=''] is not always a reliable selector, because
     * a *structuralDirective with `let var = something` will have value = ''
     */
    return (attrSpan.start.offset === keySpan.start.offset &&
        attrSpan.start.line === keySpan.start.line &&
        attrSpan.start.col === keySpan.start.col &&
        attrSpan.end.offset === keySpan.end.offset &&
        attrSpan.end.line === keySpan.end.line &&
        attrSpan.end.col === keySpan.end.col);
}
function getStartPos(expected) {
    switch (expected.orderType) {
        case OrderType.StructuralDirective:
            return expected.sourceSpan.start.offset - 1;
        default:
            return expected.sourceSpan.start.offset;
    }
}
function getEndPos(expected) {
    switch (expected.orderType) {
        case OrderType.StructuralDirective:
            return (expected.sourceSpan.end.offset +
                (isValuelessStructuralDirective(expected) ? 0 : 1));
        default:
            return expected.sourceSpan.end.offset;
    }
}
