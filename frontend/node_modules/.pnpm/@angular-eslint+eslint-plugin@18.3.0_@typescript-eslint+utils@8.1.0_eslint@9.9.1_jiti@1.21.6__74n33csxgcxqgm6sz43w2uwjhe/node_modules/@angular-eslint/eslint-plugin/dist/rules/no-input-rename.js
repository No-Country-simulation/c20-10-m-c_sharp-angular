"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RULE_NAME = void 0;
const utils_1 = require("@angular-eslint/utils");
const utils_2 = require("@typescript-eslint/utils");
const create_eslint_rule_1 = require("../utils/create-eslint-rule");
exports.RULE_NAME = 'no-input-rename';
const STYLE_GUIDE_LINK = 'https://angular.dev/style-guide#style-05-13';
exports.default = (0, create_eslint_rule_1.createESLintRule)({
    name: exports.RULE_NAME,
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Ensures that input bindings are not aliased',
            recommended: 'recommended',
        },
        fixable: 'code',
        hasSuggestions: true,
        schema: [
            {
                type: 'object',
                properties: {
                    allowedNames: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                        description: 'A list with allowed input names',
                        uniqueItems: true,
                    },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            noInputRename: `Input bindings should not be aliased (${STYLE_GUIDE_LINK})`,
            suggestRemoveAliasName: 'Remove alias name',
            suggestReplaceOriginalNameWithAliasName: 'Remove alias name and use it as the original name',
        },
    },
    defaultOptions: [{ allowedNames: [] }],
    create(context, [{ allowedNames = [] }]) {
        let selectors = new Set();
        const ariaAttributeKeys = (0, utils_1.getAriaAttributeKeys)();
        let selectorDirectiveName;
        return {
            [utils_1.Selectors.COMPONENT_OR_DIRECTIVE_SELECTOR_LITERAL](node) {
                const nodeRawText = utils_1.ASTUtils.getRawText(node);
                const bracketMatchResults = nodeRawText.match(/\[(.*?)\]/);
                if (bracketMatchResults) {
                    selectorDirectiveName = bracketMatchResults[1];
                }
                selectors = new Set((0, utils_1.withoutBracketsAndWhitespaces)(nodeRawText).split(','));
            },
            [utils_1.Selectors.INPUT_ALIAS](node) {
                const propertyOrMethodDefinition = utils_1.ASTUtils.getNearestNodeFrom(node, utils_1.ASTUtils.isPropertyOrMethodDefinition);
                if (!propertyOrMethodDefinition ||
                    !utils_2.ASTUtils.isIdentifier(propertyOrMethodDefinition.key)) {
                    return;
                }
                let isAliasMetadataProperty = false;
                if (node.parent && utils_1.ASTUtils.isProperty(node.parent)) {
                    if (utils_1.ASTUtils.getRawText(node.parent.key) !== 'alias') {
                        // We're within an Input decorator metadata object, but it is not the alias property
                        return;
                    }
                    isAliasMetadataProperty = true;
                }
                const aliasName = utils_1.ASTUtils.getRawText(node);
                const propertyName = utils_1.ASTUtils.getRawText(propertyOrMethodDefinition.key);
                if (allowedNames.includes(aliasName) ||
                    (ariaAttributeKeys.has(aliasName) &&
                        propertyName === (0, utils_1.kebabToCamelCase)(aliasName))) {
                    return;
                }
                const inputCallExpression = utils_1.ASTUtils.getNearestNodeFrom(node, utils_1.ASTUtils.isCallExpression);
                if (inputCallExpression &&
                    utils_2.ASTUtils.isIdentifier(inputCallExpression.callee) &&
                    inputCallExpression.callee.name === 'Input' &&
                    utils_1.ASTUtils.isObjectExpression(inputCallExpression.arguments?.[0])) {
                    const [firstArg] = inputCallExpression.arguments;
                    const aliasProperty = firstArg.properties.find((property) => utils_1.ASTUtils.isProperty(property) &&
                        utils_1.ASTUtils.getRawText(property.key) === 'alias');
                    if (!aliasProperty) {
                        return;
                    }
                }
                if (aliasName === propertyName) {
                    context.report({
                        node,
                        messageId: 'noInputRename',
                        fix: (fixer) => {
                            if (node.parent && isAliasMetadataProperty) {
                                return fixer.remove(node.parent);
                            }
                            return fixer.remove(node);
                        },
                    });
                }
                else if (!isAliasNameAllowed(selectors, propertyName, aliasName, selectorDirectiveName)) {
                    context.report({
                        node,
                        messageId: 'noInputRename',
                        suggest: [
                            {
                                messageId: 'suggestRemoveAliasName',
                                fix: (fixer) => {
                                    if (node.parent && isAliasMetadataProperty) {
                                        return fixer.remove(node.parent);
                                    }
                                    return fixer.remove(node);
                                },
                            },
                            {
                                messageId: 'suggestReplaceOriginalNameWithAliasName',
                                fix: (fixer) => [
                                    fixer.remove(node),
                                    fixer.replaceText(propertyOrMethodDefinition.key, aliasName.includes('-') ? `'${aliasName}'` : aliasName),
                                ],
                            },
                        ],
                    });
                }
            },
            [utils_1.Selectors.INPUTS_METADATA_PROPERTY_LITERAL](node) {
                const ancestorMaybeHostDirectiveAPI = node.parent?.parent?.parent?.parent?.parent;
                if (ancestorMaybeHostDirectiveAPI &&
                    utils_1.ASTUtils.isProperty(ancestorMaybeHostDirectiveAPI)) {
                    /**
                     * Angular v15 introduced the directive composition API: https://angular.dev/guide/directives/directive-composition-api
                     * Renaming host directive inputs using this API is not a bad practice and should not be reported
                     */
                    const hostDirectiveAPIPropertyName = 'hostDirectives';
                    if ((utils_1.ASTUtils.isLiteral(ancestorMaybeHostDirectiveAPI.key) &&
                        ancestorMaybeHostDirectiveAPI.key.value ===
                            hostDirectiveAPIPropertyName) ||
                        (utils_2.ASTUtils.isIdentifier(ancestorMaybeHostDirectiveAPI.key) &&
                            ancestorMaybeHostDirectiveAPI.key.name ===
                                hostDirectiveAPIPropertyName)) {
                        return;
                    }
                }
                const [propertyName, aliasName] = (0, utils_1.withoutBracketsAndWhitespaces)(utils_1.ASTUtils.getRawText(node)).split(':');
                if (!aliasName ||
                    allowedNames.includes(aliasName) ||
                    (ariaAttributeKeys.has(aliasName) &&
                        propertyName === (0, utils_1.kebabToCamelCase)(aliasName))) {
                    return;
                }
                if (aliasName === propertyName) {
                    context.report({
                        node,
                        messageId: 'noInputRename',
                        fix: (fixer) => fixer.replaceText(node, utils_1.ASTUtils.getReplacementText(node, propertyName)),
                    });
                }
                else if (!isAliasNameAllowed(selectors, propertyName, aliasName, selectorDirectiveName)) {
                    context.report({
                        node,
                        messageId: 'noInputRename',
                        suggest: [
                            ['suggestRemoveAliasName', propertyName],
                            ['suggestReplaceOriginalNameWithAliasName', aliasName],
                        ].map(([messageId, name]) => ({
                            messageId,
                            fix: (fixer) => fixer.replaceText(node, utils_1.ASTUtils.getReplacementText(node, name)),
                        })),
                    });
                }
            },
            'ClassDeclaration:exit'() {
                selectors = new Set();
            },
        };
    },
});
function composedName(selector, propertyName) {
    return `${selector}${(0, utils_1.capitalize)(propertyName)}`;
}
function isAliasNameAllowed(selectors, propertyName, aliasName, selectorDirectiveName) {
    return [...selectors].some((selector) => {
        return (selector === aliasName ||
            selectorDirectiveName === aliasName ||
            composedName(selector, propertyName) === aliasName);
    });
}
